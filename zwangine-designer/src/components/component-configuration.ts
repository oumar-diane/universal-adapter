import file from "@/assets/component/file.png"
import scheduler from "@/assets/component/scheduler.png"
import pgsql from "@/assets/component/pgsql.png"

export const config = [
    {
        "name": "file",
        "title": "File",
        "logoPath": file,
        "operations":[
            {
                "name": "read",
                "title": "File Read",
                "type": 'fileNode',
                "description": "Read files.",
                "deprecated": false,
                "supportLevel": "Stable",
                "consumerOnly": false,
                "lenientProperties": false,
                "browsable": true,
                "remote": true,
                "properties": {
                    "directoryName": { "index": 0, "target":"directoryName", "kind": "path", "displayName": "Directory Name", "group": "common", "label": "", "required": true, "type": "string", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The starting directory" },
                    "charset": { "index": 1, "target":"charset", "kind": "parameter", "displayName": "Charset", "group": "common", "label": "", "required": false, "type": "string", "operation": "read", "component":"file", "deprecated": false, "autowired": false, "secret": false, "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Zwangine to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Zwangine may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages." },
                    "doneFileName": { "index": 2, "target":"doneFileName", "kind": "parameter", "displayName": "Done File Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Producer: If provided, then Zwangine will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Zwangine will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders." },
                    "fileName": { "index": 3, "target":"fileName", "kind": "parameter", "displayName": "File Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the ZwangineFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the ZwangineOverruleFileName header which takes precedence over any existing ZwangineFileName header; the ZwangineOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store ZwangineFileName and have to restore it afterwards." },
                    "noop": { "index": 6, "target":"noop", "kind": "parameter", "displayName": "Noop", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Zwangine will set idempotent=true as well, to avoid consuming the same files over and over again." },
                    "recursive": { "index": 9, "target":"recursive", "kind": "parameter", "displayName": "Recursive", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If a directory, will look for files in all the sub-directories as well." },
                    "extendedAttributes": { "index": 10, "target":"extendedAttributes", "kind": "parameter", "displayName": "Extended Attributes", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime, it supports basic wildcard like posix:, basic:lastAccessTime" },
                    "includeHiddenDirs": { "index": 11, "target":"includeHiddenDirs", "kind": "parameter", "displayName": "Include Hidden Dirs", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to accept hidden directories. Directories which names starts with dot are regarded as a hidden directory, and by default are not included. Set this option to true to include hidden directories in the file consumer." },
                    "includeHiddenFiles": { "index": 12, "target":"includeHiddenFiles", "kind": "parameter", "displayName": "Include Hidden Files", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to accept hidden files. Files which names starts with dot is regarded as a hidden file, and by default not included. Set this option to true to include hidden files in the file consumer." },
                    "includeExt": { "index": 13, "target":"includeExt", "kind": "parameter", "displayName": "Include Ext", "group": "filter", "label": "consumer,filter", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options." },
                    "maxDepth": { "index": 14, "target":"maxDepth", "kind": "parameter", "displayName": "Max Depth", "group": "filter", "label": "consumer,filter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 2147483647, "description": "The maximum depth to traverse when recursively processing a directory." },
                    "minDepth": { "index": 15, "target":"minDepth", "kind": "parameter", "displayName": "Min Depth", "group": "filter", "label": "consumer,filter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory." },
                }
            },
            {
                "name": "write",
                "title": "File Write",
                "type": 'fileNode',
                "description": "Write files.",
                "deprecated": false,
                "supportLevel": "Stable",
                "consumerOnly": false,
                "lenientProperties": false,
                "browsable": true,
                "remote": true,
                "properties": {
                    "directoryName": { "index": 0, "target":"directoryName", "kind": "path", "displayName": "Directory Name", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.io.File", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The starting directory" },
                    "charset": { "index": 1, "target":"charset", "kind": "parameter", "displayName": "Charset", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Zwangine to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Zwangine may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages." },
                    "fileName": { "index": 3, "target":"fileName", "kind": "parameter", "displayName": "File Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the ZwangineFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the ZwangineOverruleFileName header which takes precedence over any existing ZwangineFileName header; the ZwangineOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store ZwangineFileName and have to restore it afterwards." },
                    "appendChars": { "index": 26, "target":"appendChars", "kind": "parameter", "displayName": "Append Chars", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Used to append characters (text) after writing files. This can for example be used to add new lines or other separators when writing and appending new files or existing files. To specify new-line (slash-n or slash-r) or tab (slash-t) characters then escape with an extra slash, eg slash-slash-n." },
                    "chmod": { "index": 35, "target":"chmod", "kind": "parameter", "displayName": "Chmod", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Specify the file permissions that are sent by the producer, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it." },
                    "chmodDirectory": { "index": 36, "target":"chmodDirectory", "kind": "parameter", "displayName": "Chmod Directory", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it." },
                    "forceWrites": { "index": 38, "target":"forceWrites", "kind": "parameter", "displayName": "Force Writes", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to force syncing, writes to the file system. You can turn this off if you do not want this level of guarantee, for example, if writing to logs / audit logs etc.; this would yield better performance." },
                }
            },
            {
                "name": "watch",
                "title": "File Watch",
                "type": 'fileNode',
                "description": "Watch files.",
                "deprecated": false,
                "supportLevel": "Stable",
                "consumerOnly": false,
                "lenientProperties": false,
                "browsable": true,
                "remote": true,
                "properties": {
                    "directoryName": { "index": 0, "target":"directoryName", "kind": "path", "displayName": "Directory Name", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.io.File", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The starting directory" },
                    "charset": { "index": 1, "target":"charset", "kind": "parameter", "displayName": "Charset", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Zwangine to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Zwangine may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages." },
                    "fileName": { "index": 3, "target":"fileName", "kind": "parameter", "displayName": "File Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the ZwangineFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the ZwangineOverruleFileName header which takes precedence over any existing ZwangineFileName header; the ZwangineOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store ZwangineFileName and have to restore it afterwards." },
                    "appendChars": { "index": 26, "target":"appendChars", "kind": "parameter", "displayName": "Append Chars", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Used to append characters (text) after writing files. This can for example be used to add new lines or other separators when writing and appending new files or existing files. To specify new-line (slash-n or slash-r) or tab (slash-t) characters then escape with an extra slash, eg slash-slash-n." },
                    "chmod": { "index": 35, "target":"chmod", "kind": "parameter", "displayName": "Chmod", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Specify the file permissions that are sent by the producer, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it." },
                    "chmodDirectory": { "index": 36, "target":"chmodDirectory", "kind": "parameter", "displayName": "Chmod Directory", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it." },
                    "forceWrites": { "index": 38, "target":"forceWrites ", "kind": "parameter", "displayName": "Force Writes", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to force syncing, writes to the file system. You can turn this off if you do not want this level of guarantee, for example, if writing to logs / audit logs etc.; this would yield better performance." },
                }
            }
        ],
        "headers": {
            "ZwangineFileLength": { "index": 0, "target":"charset", "kind": "header", "displayName": "#{file_length}", "group": "consumer", "label": "consumer", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A long value containing the file size.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_LENGTH" },
            "ZwangineFileLastModified": { "index": 1, "target":"charset", "kind": "header", "displayName": "#{file_last_modified}", "group": "consumer", "label": "consumer", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A Long value containing the last modified timestamp of the file.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_LAST_MODIFIED" },
            "ZwangineFileLocalWorkPath": { "index": 2, "target":"charset", "kind": "header", "displayName": "#{file_local_work_path}", "group": "producer", "label": "producer", "required": false, "javaType": "File", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The local work path", "constantName": "org.zenithblox.component.file.FileConstants#FILE_LOCAL_WORK_PATH" },
            "ZwangineFileNameOnly": { "index": 3, "target":"charset", "kind": "header", "displayName": "#{file_name_only}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "Only the file name (the name with no leading paths).", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME_ONLY" },
            "ZwangineFileName": { "index": 4, "target":"charset", "kind": "header", "displayName": "#{file_name}", "group": "common", "label": "", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "(producer) Specifies the name of the file to write (relative to the endpoint directory). This name can be a String; a String with a file or simple Language expression; or an Expression object. If it's null then Zwangine will auto-generate a filename based on the message unique ID. (consumer) Name of the consumed file as a relative file path with offset from the starting directory configured on the endpoint.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME" },
            "ZwangineFileNameConsumed": { "index": 5, "target":"charset", "kind": "header", "displayName": "#{file_last_consumed}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The name of the file that has been consumed", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME_CONSUMED" },
            "ZwangineFileAbsolute": { "index": 6, "target":"charset", "kind": "header", "displayName": "#{is_file_absolute}", "group": "consumer", "label": "consumer", "required": false, "javaType": "Boolean", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A boolean option specifying whether the consumed file denotes an absolute path or not. Should normally be false for relative paths. Absolute paths should normally not be used but we added to the move option to allow moving files to absolute paths. But can be used elsewhere as well.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_ABSOLUTE" },
            "ZwangineFileAbsolutePath": { "index": 7, "target":"charset", "kind": "header", "displayName": "#{file_absolute_path}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The absolute path to the file. For relative files this path holds the relative path instead.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_ABSOLUTE_PATH" },
            "ZwangineFileExtendedAttributes": { "index": 8, "target":"charset", "kind": "header", "displayName": "#{file_extended_attribute}", "group": "consumer", "label": "consumer", "required": false, "javaType": "Map<String, Object>", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The extended attributes of the file", "constantName": "org.zenithblox.component.file.FileConstants#FILE_EXTENDED_ATTRIBUTES" },
            "ZwangineFileContentType": { "index": 9, "target":"charset", "kind": "header", "displayName": "#{file_content_type}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The content type of the file", "constantName": "org.zenithblox.component.file.FileConstants#FILE_CONTENT_TYPE" },
            "ZwangineFilePath": { "index": 10, "target":"charset", "kind": "header", "displayName": "#{file_last_path}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The file path. For relative files this is the starting directory. For absolute files this is the absolute path.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_PATH" },
            "ZwangineFileRelativePath": { "index": 11, "target":"charset", "kind": "header", "displayName": "#{file_relative_path}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The relative path.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_RELATIVE_PATH" },
            "ZwangineFileParent": { "index": 12, "target":"charset", "kind": "header", "displayName": "#{file_parent}", "group": "common", "label": "", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The parent path.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_PARENT" },
            "ZwangineFileNameProduced": { "index": 13, "target":"charset", "kind": "header", "displayName": "#{file_name_produced}", "group": "producer", "label": "producer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The actual absolute filepath (path name) for the output file that was written. This header is set by Zwangine and its purpose is providing end-users with the name of the file that was written.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME_PRODUCED" },
            "ZwangineOverruleFileName": { "index": 14, "target":"charset", "kind": "header", "displayName": "#{file_overru_file_name}", "group": "producer", "label": "producer", "required": false, "javaType": "Object", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "Is used for overruling ZwangineFileName header and use the value instead (but only once, as the producer will remove this header after writing the file). The value can be only be a String. Notice that if the option fileName has been configured, then this is still being evaluated.", "constantName": "org.zenithblox.component.file.FileConstants#OVERRULE_FILE_NAME" },
            "ZwangineFileInitialOffset": { "index": 15, "target":"charset", "kind": "header", "displayName": "#{file_initial_offset}", "group": "consumer", "label": "consumer", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A long value containing the initial offset.", "constantName": "org.zenithblox.component.file.FileConstants#INITIAL_OFFSET" }
        }

    },
    {
        "name": "scheduler",
        "title": "Scheduler",
        "logoPath": scheduler,
        "operations":[
            {
                "name": "scheduler",
                "title": "Schedule",
                "type": 'schedulerNode',
                "description": "Schedule Task",
                "deprecated": false,
                "supportLevel": "Stable",
                "consumerOnly": false,
                "lenientProperties": false,
                "browsable": true,
                "remote": true,
                "properties": {
                    "directoryName": { "index": 0, "kind": "path", "displayName": "Directory Name", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.io.File", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The starting directory" },
                    "charset": { "index": 1, "kind": "parameter", "displayName": "Charset", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Zwangine to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Zwangine may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages." },
                    "doneFileName": { "index": 2, "kind": "parameter", "displayName": "Done File Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Producer: If provided, then Zwangine will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Zwangine will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders." },
                    "fileName": { "index": 3, "kind": "parameter", "displayName": "File Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the ZwangineFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the ZwangineOverruleFileName header which takes precedence over any existing ZwangineFileName header; the ZwangineOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store ZwangineFileName and have to restore it afterwards." },
                    "noop": { "index": 6, "kind": "parameter", "displayName": "Noop", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Zwangine will set idempotent=true as well, to avoid consuming the same files over and over again." },
                    "recursive": { "index": 9, "kind": "parameter", "displayName": "Recursive", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If a directory, will look for files in all the sub-directories as well." },
                    "extendedAttributes": { "index": 15, "kind": "parameter", "displayName": "Extended Attributes", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime, it supports basic wildcard like posix:, basic:lastAccessTime" },
                    "includeHiddenDirs": { "index": 16, "kind": "parameter", "displayName": "Include Hidden Dirs", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to accept hidden directories. Directories which names starts with dot are regarded as a hidden directory, and by default are not included. Set this option to true to include hidden directories in the file consumer." },
                    "includeHiddenFiles": { "index": 17, "kind": "parameter", "displayName": "Include Hidden Files", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to accept hidden files. Files which names starts with dot is regarded as a hidden file, and by default not included. Set this option to true to include hidden files in the file consumer." },
                    "includeExt": { "index": 63, "kind": "parameter", "displayName": "Include Ext", "group": "filter", "label": "consumer,filter", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options." },
                    "maxDepth": { "index": 64, "kind": "parameter", "displayName": "Max Depth", "group": "filter", "label": "consumer,filter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 2147483647, "description": "The maximum depth to traverse when recursively processing a directory." },
                    "minDepth": { "index": 66, "kind": "parameter", "displayName": "Min Depth", "group": "filter", "label": "consumer,filter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory." },
                    "scheduledExecutorService": { "index": 91, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
                }
            },
            {
                "name": "timer",
                "title": "Timer",
                "type": 'timerNode',
                "description": "Generate messages in specified intervals using java.util.Timer.",
                "deprecated": false,
                "supportLevel": "Stable",
                "consumerOnly": false,
                "lenientProperties": false,
                "browsable": true,
                "remote": true,
                "syntax": "timer:timerName",
                "properties": {
                    "timerName": { "index": 0, "target":"timerName", "kind": "path", "displayName": "Timer Name", "group": "consumer", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The name of the timer" },
                    "delay": { "index": 1, "target":"delay", "kind": "parameter", "displayName": "Delay", "group": "consumer", "label": "", "required": false, "type": "duration", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "1000", "description": "The number of milliseconds to wait before the first event is generated. Should not be used in conjunction with the time option. The default value is 1000." },
                    "fixedRate": { "index": 2, "target":"fixedRate", "kind": "parameter", "displayName": "Fixed Rate", "group": "consumer", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Events take place at approximately regular intervals, separated by the specified period." },
                    "includeMetadata": { "index": 3, "target":"includeMetadata", "kind": "parameter", "displayName": "Include Metadata", "group": "consumer", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to include metadata in the exchange such as fired time, timer name, timer count etc." },
                    "period": { "index": 4, "target":"period", "kind": "parameter", "displayName": "Period", "group": "consumer", "label": "", "required": false, "type": "duration", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "1000", "description": "Generate periodic events every period. Must be zero or positive value. The default value is 1000." },
                    "repeatCount": { "index": 5, "target":"repeatCount", "kind": "parameter", "displayName": "Repeat Count", "group": "consumer", "label": "", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "description": "Specifies a maximum limit for the number of fires. Therefore, if you set it to 1, the timer will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
                    "daemon": { "index": 9, "target":"daemon", "kind": "parameter", "displayName": "Daemon", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Specifies whether the thread associated with the timer endpoint runs as a daemon. The default value is true." },
                    "pattern": { "index": 10, "target":"pattern", "kind": "parameter", "displayName": "Pattern", "group": "advanced", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Allows you to specify a custom Date pattern to use for setting the time option using URI syntax." },
                    "synchronous": { "index": 11, "target":"synchronous", "kind": "parameter", "displayName": "Synchronous", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Sets whether synchronous processing should be strictly used" },
                    "time": { "index": 12, "target":"time", "kind": "parameter", "displayName": "Time", "group": "advanced", "label": "advanced", "required": false, "type": "string", "javaType": "java.util.Date", "deprecated": false, "autowired": false, "secret": false, "description": "A java.util.Date the first event should be generated. If using the URI, the pattern expected is: yyyy-MM-dd HH:mm:ss or yyyy-MM-dd'T'HH:mm:ss." },
                    "timer": { "index": 13, "target":"timer", "kind": "parameter", "displayName": "Timer", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Timer", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Timer" },
                    "runLoggingLevel": { "index": 14, "runLoggingLevel":"charset", "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.zenithblox.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start complete log line when it polls. This option allows you to configure the logging level for that." }
                }
            },
        ],
        "headers": {
            "ZwangineFileLength": { "index": 0, "target":"charset", "kind": "header", "displayName": "#{file_length}", "group": "consumer", "label": "consumer", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A long value containing the file size.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_LENGTH" },
            "ZwangineFileLastModified": { "index": 1, "target":"charset", "kind": "header", "displayName": "#{file_last_modified}", "group": "consumer", "label": "consumer", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A Long value containing the last modified timestamp of the file.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_LAST_MODIFIED" },
            "ZwangineFileLocalWorkPath": { "index": 2, "target":"charset", "kind": "header", "displayName": "#{file_local_work_path}", "group": "producer", "label": "producer", "required": false, "javaType": "File", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The local work path", "constantName": "org.zenithblox.component.file.FileConstants#FILE_LOCAL_WORK_PATH" },
            "ZwangineFileNameOnly": { "index": 3, "target":"charset", "kind": "header", "displayName": "#{file_name_only}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "Only the file name (the name with no leading paths).", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME_ONLY" },
            "ZwangineFileName": { "index": 4, "target":"charset", "kind": "header", "displayName": "#{file_name}", "group": "common", "label": "", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "(producer) Specifies the name of the file to write (relative to the endpoint directory). This name can be a String; a String with a file or simple Language expression; or an Expression object. If it's null then Zwangine will auto-generate a filename based on the message unique ID. (consumer) Name of the consumed file as a relative file path with offset from the starting directory configured on the endpoint.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME" },
            "ZwangineFileNameConsumed": { "index": 5, "target":"charset", "kind": "header", "displayName": "#{file_last_consumed}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The name of the file that has been consumed", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME_CONSUMED" },
            "ZwangineFileAbsolute": { "index": 6, "target":"charset", "kind": "header", "displayName": "#{is_file_absolute}", "group": "consumer", "label": "consumer", "required": false, "javaType": "Boolean", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A boolean option specifying whether the consumed file denotes an absolute path or not. Should normally be false for relative paths. Absolute paths should normally not be used but we added to the move option to allow moving files to absolute paths. But can be used elsewhere as well.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_ABSOLUTE" },
            "ZwangineFileAbsolutePath": { "index": 7, "target":"charset", "kind": "header", "displayName": "#{file_absolute_path}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The absolute path to the file. For relative files this path holds the relative path instead.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_ABSOLUTE_PATH" },
            "ZwangineFileExtendedAttributes": { "index": 8, "target":"charset", "kind": "header", "displayName": "#{file_extended_attribute}", "group": "consumer", "label": "consumer", "required": false, "javaType": "Map<String, Object>", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The extended attributes of the file", "constantName": "org.zenithblox.component.file.FileConstants#FILE_EXTENDED_ATTRIBUTES" },
            "ZwangineFileContentType": { "index": 9, "target":"charset", "kind": "header", "displayName": "#{file_content_type}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The content type of the file", "constantName": "org.zenithblox.component.file.FileConstants#FILE_CONTENT_TYPE" },
            "ZwangineFilePath": { "index": 10, "target":"charset", "kind": "header", "displayName": "#{file_last_path}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The file path. For relative files this is the starting directory. For absolute files this is the absolute path.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_PATH" },
            "ZwangineFileRelativePath": { "index": 11, "target":"charset", "kind": "header", "displayName": "#{file_relative_path}", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The relative path.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_RELATIVE_PATH" },
            "ZwangineFileParent": { "index": 12, "target":"charset", "kind": "header", "displayName": "#{file_parent}", "group": "common", "label": "", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The parent path.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_PARENT" },
            "ZwangineFileNameProduced": { "index": 13, "target":"charset", "kind": "header", "displayName": "#{file_name_produced}", "group": "producer", "label": "producer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The actual absolute filepath (path name) for the output file that was written. This header is set by Zwangine and its purpose is providing end-users with the name of the file that was written.", "constantName": "org.zenithblox.component.file.FileConstants#FILE_NAME_PRODUCED" },
            "ZwangineOverruleFileName": { "index": 14, "target":"charset", "kind": "header", "displayName": "#{file_overru_file_name}", "group": "producer", "label": "producer", "required": false, "javaType": "Object", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "Is used for overruling ZwangineFileName header and use the value instead (but only once, as the producer will remove this header after writing the file). The value can be only be a String. Notice that if the option fileName has been configured, then this is still being evaluated.", "constantName": "org.zenithblox.component.file.FileConstants#OVERRULE_FILE_NAME" },
            "ZwangineFileInitialOffset": { "index": 15, "target":"charset", "kind": "header", "displayName": "#{file_initial_offset}", "group": "consumer", "label": "consumer", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "A long value containing the initial offset.", "constantName": "org.zenithblox.component.file.FileConstants#INITIAL_OFFSET" },
            "ZwangineTimerFiredTime": { "index": 0, "target":"charset", "kind": "header", "displayName": "", "group": "consumer", "label": "", "required": false, "javaType": "Date", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The fired time", "constantName": "org.zenithblox.component.timer.TimerConstants#HEADER_FIRED_TIME" },
            "ZwangineMessageTimestamp": { "index": 1, "target":"charset", "kind": "header", "displayName": "", "group": "consumer", "label": "", "required": false, "javaType": "long", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The timestamp of the message", "constantName": "org.zenithblox.component.timer.TimerConstants#HEADER_MESSAGE_TIMESTAMP" }
        }

    },
    {
        "name": "pgevent",
        "title": "PostgresSQL",
        "logoPath": pgsql,
        "operations":[
            {
                "name": "pgevent",
                "title": "PG Event",
                "type": 'pgeventNode',
                "description": "Send and Receive PostgreSQL events via NOTIFY and Listen commands.",
                "deprecated": false,
                "supportLevel": "Stable",
                "consumerOnly": false,
                "lenientProperties": false,
                "browsable": true,
                "remote": true,
                "syntax": "pgevent:host:port/database/channel",
                "properties": {
                    "host": { "index": 0, "target":"host", "kind": "path", "displayName": "Host", "group": "common", "label": "", "required": false, "type": "string", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "localhost", "description": "To connect using hostname and port to the database." },
                    "port": { "index": 1, "target":"port", "kind": "path", "displayName": "Port", "group": "common", "label": "", "required": false, "type": "integer", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "5432", "description": "To connect using hostname and port to the database." },
                    "database": { "index": 2, "target":"database", "kind": "path", "displayName": "Database", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The database name. The database name can take any characters because it is sent as a quoted identifier. It is part of the endpoint URI, so diacritical marks and non-Latin letters have to be URL encoded." },
                    "channel": { "index": 3, "target":"channel", "kind": "path", "displayName": "Channel", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The channel name" },
                    "bridgeErrorHandler": { "index": 4, "target":"bridgeErrorHandler", "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Zwangine routing Error Handler, which mean any exceptions (if possible) occurred while the Zwangine consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Zwangine to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Zwangine component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.zenithblox.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
                    "exceptionHandler": { "index": 5, "target":"exceptionHandler", "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.zenithblox.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
                    "exchangePattern": { "index": 6, "target":"exchangePattern", "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.zenithblox.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
                    "lazyStartProducer": { "index": 7, "target":"lazyStartProducer", "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow ZwangineContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Zwangine's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
                    "datasource": { "index": 8, "target":"datasource", "kind": "parameter", "displayName": "Datasource", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "javax.sql.DataSource", "deprecated": false, "autowired": false, "secret": false, "description": "To connect using the given javax.sql.DataSource instead of using hostname and port." },
                    "pass": { "index": 9, "target":"pass", "kind": "parameter", "displayName": "Pass", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "description": "Password for login" },
                    "user": { "index": 10, "target":"user", "kind": "parameter", "displayName": "User", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "defaultValue": "postgres", "description": "Username for login" }
                }
            },
        ],
        "headers": {
            "channel": { "index": 0, "kind": "header", "displayName": "", "group": "consumer", "label": "consumer", "required": false, "javaType": "String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The name of the channel.", "constantName": "org.zenithblox.component.pgevent.PgEventConstants#HEADER_CHANNEL" }
        }
    },
]